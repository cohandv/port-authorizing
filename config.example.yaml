server:
  port: 8080
  max_connection_duration: 2h
  base_url: "http://localhost:8080"  # Base URL for approval callbacks

auth:
  jwt_secret: "your-secret-key-change-this-in-production"
  token_expiry: 24h

  # Authentication providers (supports multiple)
  providers:
    # Local authentication (simple username/password)
    - name: local
      type: local
      enabled: true
      config: {}

    # OpenID Connect (via Keycloak or other OIDC provider)
    - name: keycloak
      type: oidc
      enabled: false
      config:
        issuer: "http://localhost:8180/realms/portauth"
        client_id: "port-authorizing"
        client_secret: "your-client-secret-change-in-production"
        redirect_url: "http://localhost:8080/auth/callback/oidc"
        roles_claim: "roles"
        username_claim: "preferred_username"

    # LDAP authentication
    - name: corporate-ldap
      type: ldap
      enabled: false
      config:
        url: "localhost:389"
        bind_dn: "cn=admin,dc=portauth,dc=local"
        bind_password: "adminpass"
        user_base_dn: "ou=users,dc=portauth,dc=local"
        user_filter: "(uid=%s)"
        group_base_dn: "ou=groups,dc=portauth,dc=local"
        group_filter: "(member=%s)"
        use_tls: "false"
        skip_tls_verify: "true"

    # SAML2 authentication
    - name: corporate-saml
      type: saml2
      enabled: false
      config:
        idp_metadata_url: "https://idp.example.com/metadata"
        sp_entity_id: "port-authorizing"
        sp_acs_url: "http://localhost:8080/auth/callback/saml2"

  # Legacy local users (backward compatible)
  users:
    - username: admin
      password: admin123  # Use hashed passwords in production
      roles:
        - admin
    - username: developer
      password: dev123
      roles:
        - developer
    - username: qa-user
      password: qa123
      roles:
        - qa

connections:
  # PostgreSQL test database (Docker)
  - name: postgres-test
    type: postgres
    host: localhost
    port: 5432
    duration: 3m
    tags:
      - env:test
      - type:database
      - team:backend
    backend_username: "testuser"
    backend_password: "testpass"
    backend_database: "testdb"
    metadata:
      description: "Test PostgreSQL database (Docker)"
      database: "testdb"

  # PostgreSQL staging database
  - name: postgres-staging
    type: postgres
    host: staging-db.example.com
    port: 5432
    duration: 15m
    tags:
      - env:staging
      - type:database
      - team:backend
    backend_username: "staginguser"
    backend_password: "stagingpass"
    backend_database: "app"
    metadata:
      description: "Staging PostgreSQL database"
      environment: "staging"

  # PostgreSQL production database
  - name: postgres-prod
    type: postgres
    host: prod-db.example.com
    port: 5432
    duration: 10m
    tags:
      - env:production
      - type:database
      - team:backend
      - critical:true
    backend_username: "produser"
    backend_password: "prodpass"
    backend_database: "app"
    metadata:
      description: "Production PostgreSQL database"
      environment: "production"

  # Nginx test server (Docker)
  - name: nginx-test
    type: http
    host: localhost
    port: 8888
    scheme: http
    duration: 1h
    tags:
      - env:test
      - type:web
    metadata:
      description: "Test Nginx web server (Docker)"

  # Internal API staging
  - name: api-staging
    type: http
    host: api-staging.internal.example.com
    port: 443
    scheme: https
    duration: 2h
    tags:
      - env:staging
      - type:api
      - team:backend
    metadata:
      description: "Internal REST API (Staging)"

  # Internal API production
  - name: api-prod
    type: http
    host: api.internal.example.com
    port: 443
    scheme: https
    duration: 1h
    tags:
      - env:production
      - type:api
      - team:backend
      - critical:true
    metadata:
      description: "Internal REST API (Production)"

  # Redis cache
  - name: redis-cache
    type: tcp
    host: redis.example.com
    port: 6379
    duration: 5m
    tags:
      - env:production
      - type:cache
      - team:platform
    metadata:
      description: "Redis cache server"

# Role-based access policies
# Policies define which roles can access which connections (via tags) and what they can do (whitelist)
policies:
  # Admin policy - full access to everything
  - name: admin-full-access
    roles:
      - admin
    tags:
      - env:test
      - env:staging
      - env:production
    tag_match: any  # Match if connection has ANY of these tags
    whitelist:
      - ".*"  # Allow all queries/requests
    metadata:
      description: "Admins have full access to all environments"

  # Developer policy - full access to test and staging
  - name: developer-test-staging
    roles:
      - developer
    tags:
      - env:test
    tag_match: any
    whitelist:
      - ".*"  # Allow all in test
    metadata:
      description: "Developers have full access to test environment (PostgreSQL and HTTP)"

  - name: developer-staging
    roles:
      - developer
    tags:
      - env:staging
    tag_match: any
    whitelist:
      # PostgreSQL whitelists (for postgres connections)
      - "^SELECT.*"  # Allow SELECT queries
      - "^INSERT INTO logs.*"  # Allow inserting logs
      - "^INSERT INTO events.*"  # Allow inserting events
      - "^UPDATE.*WHERE id.*"  # Allow UPDATE with WHERE clause
      - "^EXPLAIN.*"  # Allow EXPLAIN for query analysis
      # HTTP whitelists (for http/https connections)
      - "^GET .*"  # Allow all GET requests
      - "^POST /api/.*"  # Allow POST to API endpoints
      - "^PUT /api/users/[0-9]+/profile$"  # Allow updating user profiles
      - "^PATCH /api/.*"  # Allow PATCH requests
    metadata:
      description: "Developers have limited access to staging (SELECT, specific INSERTs for DBs; GET, POST, PUT, PATCH for APIs)"

  # Developer policy - read-only access to production
  - name: developer-prod-readonly
    roles:
      - developer
    tags:
      - env:production
    tag_match: any
    whitelist:
      # PostgreSQL whitelists (read-only)
      - "^SELECT.*"  # Allow SELECT queries
      - "^EXPLAIN.*"  # Allow EXPLAIN queries
      # HTTP whitelists (read-only)
      - "^GET .*"  # Allow all GET requests
      - "^HEAD .*"  # Allow HEAD requests
      - "^OPTIONS .*"  # Allow OPTIONS requests (CORS preflight)
    metadata:
      description: "Developers have read-only access to production (SELECT/EXPLAIN for DBs; GET/HEAD/OPTIONS for APIs)"

  # QA policy - full access to test, read-only to staging
  - name: qa-test-full
    roles:
      - qa
    tags:
      - env:test
    tag_match: any
    whitelist:
      - ".*"
    metadata:
      description: "QA has full access to test environment"

  - name: qa-staging-readonly
    roles:
      - qa
    tags:
      - env:staging
    tag_match: any
    whitelist:
      # PostgreSQL whitelists
      - "^SELECT.*"  # Allow SELECT queries
      # HTTP whitelists
      - "^GET .*"  # Allow all GET requests
      - "^HEAD .*"  # Allow HEAD requests
      - "^OPTIONS .*"  # Allow OPTIONS for CORS
    metadata:
      description: "QA has read-only access to staging"

  # Example: team-specific access
  - name: backend-team-databases
    roles:
      - developer
      - admin
    tags:
      - team:backend
      - type:database
    tag_match: all  # Must have ALL these tags
    whitelist:
      - ".*"
    metadata:
      description: "Backend team can access backend databases"

security:
  enable_llm_analysis: false
  llm_provider: "openai"
  llm_api_key: ""

logging:
  audit_log_path: "audit.log"
  log_level: "info"

# Approval workflow configuration
# Requires human approval for certain commands before execution
approval:
  enabled: false  # Set to true to enable approval workflow

  # Define which requests require approval (regex patterns + tags)
  patterns:
    # Require approval for DELETE operations ONLY on production databases
    - pattern: "^DELETE /.*"
      tags: ["env:production"]  # Only matches connections tagged with env:production
      tag_match: all  # "all" (default) = must have ALL tags, "any" = must have ANY tag
      timeout_seconds: 300  # 5 minutes - how long to wait for human approval

    # Require approval for POST to admin endpoints on ANY environment
    - pattern: "^POST /admin/.*"
      tags: []  # Empty tags = applies to ALL connections
      timeout_seconds: 600  # 10 minutes

    # Require approval for dangerous operations on production OR backend team databases
    - pattern: "^(DROP|TRUNCATE|ALTER) .*"
      tags: ["env:production", "team:backend"]
      tag_match: any  # Matches if connection has ANY of these tags
      timeout_seconds: 900  # 15 minutes

  # Generic webhook for approval notifications
  webhook:
    url: "https://your-approval-service.com/webhook"

  # Slack integration for approvals (with interactive buttons)
  slack:
    webhook_url: "https://hooks.slack.com/services/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"
